# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# David Tsaritov <tsaritov@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-06-26 20:13+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: David Tsaritov <tsaritov@gmail.com>, 2021\n"
"Language-Team: Russian (https://www.transifex.com/caspernetwork/teams/122124/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../theory/highway.rst:2
msgid "Highway"
msgstr "Highway"

#: ../../theory/highway.rst:5
msgid "Motivation"
msgstr "Мотивация"

#: ../../theory/highway.rst:7
msgid ""
"For a practically useful decentralized consensus protocol, proofs of two "
"theorems must be provided:"
msgstr ""
"Для практически применимого децентрализованного протокола консенсуса должны "
"быть предоставлены доказательства двух теорем:"

#: ../../theory/highway.rst:10
msgid ""
"**safety:** a theorem saying that nodes cannot come up with conflicting "
"decisions"
msgstr ""
"**безопасность:** теорема, которая сообщает, что ноды не могут давать "
"конфликтующие результаты"

#: ../../theory/highway.rst:11
msgid "**liveness:** a theorem saying that nodes will keep making decisions"
msgstr ""
"**жизнеспособность:** теорема, которая сообщает, что ноды будут продолжать "
"давать решения"

#: ../../theory/highway.rst:12
msgid "forever (so, that the blockchain will grow forever)"
msgstr "навсегда (так что блокчейн будет всегда расти)"

#: ../../theory/highway.rst:14
msgid ""
"The First theorem is just another name for the machinery of finality "
"detectors. And it is the easy one. The Second theorem tends to be "
"substantially harder to prove and these difficulties are showing up in "
"pretty much any blockchain design studied."
msgstr ""
"Первая теорема - это просто другое название механизма определителей "
"завершенности. И это самый простой вариант. Вторую теорему, как правило, "
"значительно сложнее доказать, и эти трудности проявляются практически в "
"любом изученном дизайне блокчейна."

#: ../../theory/highway.rst:19
msgid ""
"Despite the fact that the “naive” design of a blockchain described in the "
"previous chapter can actually be implemented and its observed behavior is "
"promising, so far we were not successful trying to prove the liveness "
"theorem for it."
msgstr ""
"Несмотря на то, что “наивный” дизайн блокчейна, описанный в предыдущей "
"главе, действительно может быть реализован, и его наблюдаемое поведение "
"является многообещающим, до сих пор нам не удавалось доказать теорему о "
"жизнеспособности для него."

#: ../../theory/highway.rst:23
msgid ""
"As part of this effort, we were actively looking for some hardening of "
"assumptions that would lead to a provably live protocol while maintaining "
"our key goals intact; i.e. to have a permissionless, fully decentralized, "
"Casper-based blockchain that is compatible with broadcast-based message "
"passing and a partially synchronous network."
msgstr ""
"В рамках этих усилий мы активно искали некоторое ужесточение предположений, "
"которое привело бы к доказуемому живому протоколу при сохранении наших "
"ключевых целей в неизменном виде; т. е. иметь полностью децентрализованный "
"инклюзивный блокчейн на основе Casper, совместимый с передачей сообщений на "
"основе широковещательной передачи и частично синхронной сетью."

#: ../../theory/highway.rst:29
msgid ""
"**Highway** is one of such attempts we found particularly promising. This is"
" a variant of Casper where the liveness theorem is achieved via constraining"
" message production with a pseudorandomly generated sequence of leaders "
"that, in effect leads to a predictable structure of the emerging blockdag."
msgstr ""
"**Highway** - одна из таких попыток, которую мы сочли особенно "
"многообещающей. Это вариант Casper, в котором теорема о жизнеспособности "
"достигается за счет ограничения производства сообщений псевдослучайно "
"сгенерированной последовательностью лидеров, что, по сути, приводит к "
"предсказуемой структуре возникающего блокдага."

#: ../../theory/highway.rst:35
msgid "Innovations in a nutshell"
msgstr "Инновации в двух словах"

#: ../../theory/highway.rst:37
msgid ""
"We generally see Highway as an evolution from Naive Casper Blockchain (later"
" abbreviated as NCB),  where key modifications are:"
msgstr ""
"В целом мы рассматриваем Highway как эволюцию от наивного блокчейна Casper "
"(позже сокращенно NCB), где ключевыми изменениями являются:"

#: ../../theory/highway.rst:40
msgid "Organize blocks creation around a pseudorandomly generated sequence of"
msgstr ""
"Организация создания блоков вокруг псевдослучайно сгенерированной "
"последовательности"

#: ../../theory/highway.rst:41
msgid ""
"leaders. Only a leader can produce a block. -  Use variable length of rounds"
" based on the :math:`2^n` round length idea so that the blockchain network "
"can self-adjust to achieve optimal performance. -  Replace continuous "
"bonding/unbonding with an era-based solution. This is necessary to keep the "
"solution secure (so that attackers cannot tamper with the leader sequence "
"generator)."
msgstr ""
"лидеров. Только лидер может создать блок. - Используйте переменную длин "
"раундов, основанную на идее длины раунда :math:`2^n` , чтобы сеть блокчейна "
"могла самонастраиваться для достижения оптимальной производительности. - "
"Замените непрерывное склеивание/расклеивание решением на основе эры. Это "
"необходимо для обеспечения безопасности решения (чтобы злоумышленники не "
"могли вмешаться в генератор последовательности лидеров)."

#: ../../theory/highway.rst:49
msgid "New requirements"
msgstr "Новые требования"

#: ../../theory/highway.rst:51
msgid ""
"Interestingly, in comparison to NCB, we need only one new assumption, "
"although a tough one - we need that validators have well synchronized real "
"time clocks."
msgstr ""
"Интересно, что по сравнению с NCB нам нужно только одно новое предположение,"
" хотя и сложное - нам нужно, чтобы у валидаторов были хорошо "
"синхронизированные часы реального времени."

#: ../../theory/highway.rst:54
msgid ""
"How to achieve such real-time clocks and how to secure the network against "
"intended or unintended clock drift is, in general, beyond the scope of this "
"specification. However, we give some hints on certain simple precautions to "
"be taken."
msgstr ""
"Как добиться таких часов реального времени и как защитить сеть от "
"преднамеренного или непреднамеренного смещения часов, в общем, выходит за "
"рамки данной спецификации. Тем не менее, мы даем несколько советов о "
"некоторых простых мерах предосторожности, которые необходимо принять."

#: ../../theory/highway.rst:59
msgid "Why “Highway”"
msgstr "Почему \"Highway\""

#: ../../theory/highway.rst:61
msgid ""
"To intuitively capture the key idea of the :math:`2^n` round length trick, "
"we once imagined a highway, well - a mathematical highway with infinitely "
"many lanes. Lanes are numbered with integers (all integers, also negative)."
msgstr ""
"Чтобы интуитивно уловить ключевую идею трюка с длиной раунда  :math:`2^n`, "
"мы однажды представили шоссе - Highway, скажем, математическое шоссе с "
"бесконечным количеством полос движения. Полосы движения пронумерованы целыми"
" числами (все целые числа, также отрицательные)."

#: ../../theory/highway.rst:65
msgid ""
"This highway is different because movement on it takes place in the form of "
"hops, while the speed of all cars is constant. In any given lane :math:`n`, "
"a car has to make :math:`2^n` hops to cover a unit distance."
msgstr ""
"Это шоссе отличается тем, что движение по нему происходит в виде прыжков, "
"при этом скорость всех автомобилей постоянна. В любой заданной полосе "
":math:`n`, автомобиль должен совершить :math:`2^n` прыжков, чтобы преодолеть"
" единицу расстояния."

#: ../../theory/highway.rst:69
msgid ""
"Therefore, if you switch to the lane on your left-hand side, you increase "
"the frequency of your hopping by a factor of 2. If you switch to your right-"
"hand side, you decrease the frequency by a factor of 2."
msgstr ""
"Поэтому, если вы переключаетесь на полосу движения с левой стороны, вы "
"увеличиваете частоту прыжков в 2 раза. Если вы переключитесь на правую "
"сторону, вы уменьшите частоту в 2 раза."

#: ../../theory/highway.rst:73
msgid ""
"You meet cars from the lane on your left-hand side on every jump you make. "
"For cars on your right-hand side, you meet only every second hop."
msgstr ""
"Вы встречаете машины с полосы движения с левой стороны при каждом прыжке, "
"который вы совершаете. Для автомобилей с правой стороны вы встречаете только"
" каждый второй прыжок."

#: ../../theory/highway.rst:77
msgid "Messages structure"
msgstr "Структура сообщений"

#: ../../theory/highway.rst:80
msgid ""
"While we generally keep messages structure established in NCB, we require "
"the"
msgstr ""
"Хотя мы обычно сохраняем структуру сообщений, установленную в NCB, мы "
"требуем, чтобы"

#: ../../theory/highway.rst:80
msgid "following additional fields:"
msgstr "следующие дополнительные поля:"

#: ../../theory/highway.rst:82
msgid "for every message:"
msgstr "для каждого сообщения:"

#: ../../theory/highway.rst:84
msgid "**round-id: Int** - keeps the round id that this message belongs to"
msgstr ""
"**round-id: Int** - хранит id раунда, к которому принадлежит это сообщение"

#: ../../theory/highway.rst:85
msgid ""
"**real-time-stamp: Int** - keeps the actual time of creating this message"
msgstr ""
"**real-time-stamp: Int** - отпечаток реального времени, хранит фактическое "
"время создания этого сообщения"

#: ../../theory/highway.rst:86
msgid ""
"taken from the real-time clock of the sender (must be creation as opposed to"
" sending because all fields are sealed with a digital signature)"
msgstr ""
"взятое из часов реального времени отправителя (должно быть создание, а не "
"отправка, потому что все поля запечатаны цифровой подписью)"

#: ../../theory/highway.rst:89
msgid "for blocks only:"
msgstr "для блоков только:"

#: ../../theory/highway.rst:91
msgid ""
"**magic-bit: Bit** - this is one bit field needed for leaders pseudorandom"
msgstr ""
"**magic-bit: Bit** - это однобитовое поле, необходимое для псевдослучайных "
"лидеров"

#: ../../theory/highway.rst:92
msgid "generator seed"
msgstr "генератор отбора"

#: ../../theory/highway.rst:94
msgid "for ballots only:"
msgstr "только для бюллетеней:"

#: ../../theory/highway.rst:96
msgid "**message-type: Enum** - one of: LAMBDA_RESPONSE, OMEGA"
msgstr "**message-type: Enum** - одно из: LAMBDA_RESPONSE, OMEGA"

#: ../../theory/highway.rst:98
msgid ""
"Note: The semantics of these fields is explained later in this document."
msgstr "Внимание: семантика этих полей объяснятся позже в этом документе."

#: ../../theory/highway.rst:101
msgid "Liveness strategy"
msgstr "Стратегия жизнеспсобности"

#: ../../theory/highway.rst:104
msgid "Ticks"
msgstr "Тики"

#: ../../theory/highway.rst:106
msgid ""
"Validators see time in a discrete way, namely - as the number of ticks since"
" some hardcoded point of real time. For simplicity, we assume that ticks are"
" just milliseconds since “epoch” -- the Unix time representation standard."
msgstr ""
"Валидаторы видят время дискретно, а именно - как количество тиков с "
"некоторого жестко заданного момента реального времени. Для простоты мы "
"предполагаем, что тики - это всего лишь миллисекунды с момента “эпохи” - "
"стандарта представления времени Unix."

#: ../../theory/highway.rst:111
msgid "Leaders"
msgstr "Лидеры"

#: ../../theory/highway.rst:114
msgid ""
"There is a **leader** assigned to every tick. A leader is always one from "
"the"
msgstr "Каждому тику назначается **лидер**. Лидер-это всегда один из"

#: ../../theory/highway.rst:114
msgid "currently staked validators."
msgstr "текущих валидаторов со стейком."

#: ../../theory/highway.rst:116
msgid ""
"The precise algorithm of calculating who is the leader of given tick is "
"pretty convoluted and needs a machinery that we will establish step-by-step."
" For now, it is enough to say that a validator has a recipe to calculate the"
" leader of every tick."
msgstr ""
"Точный алгоритм вычисления того, кто является лидером данного тика, довольно"
" запутан и нуждается в механизме, который мы установим шаг за шагом. На "
"данный момент достаточно сказать, что у валидатора есть рецепт для "
"вычисления лидера каждого тика."

#: ../../theory/highway.rst:122
msgid "Rounds"
msgstr "Раунды"

#: ../../theory/highway.rst:125
msgid ""
"In a leader based system, rounds are inevitable, because a leader cannot "
"lead"
msgstr ""
"В системе, основанной на лидерах, раунды неизбежны, потому что лидер не "
"может руководить"

#: ../../theory/highway.rst:125
msgid "forever. Hence, it is supposed to lead during a single round."
msgstr ""
"вечно. Следовательно, предполагается, что он лидирует в течение одного "
"раунда."

#: ../../theory/highway.rst:127
msgid ""
"Picking a fixed round length obviously leads to scaling issues. On the other"
" hand, adjusting round length on-the-fly is tricky."
msgstr ""
"Выбор фиксированной длины раунда, очевидно, приводит к проблемам с "
"масштабированием. С другой стороны, регулировать длину раунда на лету "
"сложно."

#: ../../theory/highway.rst:130
msgid ""
"In Highway, we approach the problem of automatic adjustment of round length "
"in a unique and unusual way. Every validator selects a private value "
":math:`n \\in Int`, which we call **round exponent**. Over time, a validator"
" will be automatically adjusting this value to optimize its performance and "
"the performance of the blockchain."
msgstr ""
"В Highway мы подходим к проблеме автоматической регулировки длины раунда "
"уникальным и необычным способом. Каждый валидатор выбирает частное значение"
"  :math:`n \\in Int`, которое мы называем **круглым показателем или "
"экспонентой раунда**. Со временем валидатор будет автоматически "
"корректировать это значение для оптимизации своей производительности и "
"производительности блокчейна."

#: ../../theory/highway.rst:137
msgid ""
"Given a round exponent :math:`n`, the length of a round that a validator "
"uses"
msgstr ""
"С экспонентой раунда :math:`n`, длина раунда, который использует валидатор"

#: ../../theory/highway.rst:137
msgid "for its operation is :math:`2^n` ticks."
msgstr "для своей работы -  :math:`2^n`  тиков."

#: ../../theory/highway.rst:139
msgid ""
"So, effectively, rounds live in sort of parallel worlds (“lanes of the "
"highway”), where all validators with same round exponent :math:`n` have the "
"same schedule of rounds. On the other hand, if we compare two validators, "
"**Alice** and **Bob**, **Alice** using round exponent :math:`n`, **Bob** "
"using round exponent :math:`m`, and assuming :math:`n < m`, then:"
msgstr ""
"Так что, по своей сути, раунды живут в параллельных мирах (\"полосы "
"трассы\"), где все валидаторы с одинаковыми экспонентами раунда :math:`n` "
"имеют одинаковое расписание раундов. С другой стороны, если мы сравним двух "
"валидаторов, **Элис** и **Боб**, **Элис** использует экспоненту раунда "
":math:`n`, **Боб** использует экспоненту раунда :math:`m`, и предполагая, "
"что :math:`n < m`, получаем:"

#: ../../theory/highway.rst:145
msgid "**Alice** is :math:`2^{m-n}` faster than **Bob**"
msgstr "**Элис** на :math:`2^{m-n}` быстрее, чем **Боб**"

#: ../../theory/highway.rst:146
msgid "**Alice** participates in all rounds that **Bob** knows about"
msgstr "**Элис** участвует во всех раундах, о которых знает **Боб**"

#: ../../theory/highway.rst:147
msgid ""
"**Bob** participates only in some rounds that **Alice** knows about - once"
msgstr ""
"**Боб** участвует только в некоторых раундах, о которых известно **Элис**, "
"так"

#: ../../theory/highway.rst:148
msgid "every :math:`2^{m-n}` **Alice**\\ ’s rounds"
msgstr "каждые :math:`2^{m-n}` раундов **Элис**"

#: ../../theory/highway.rst:150
msgid ""
"A round is identified by the tick at which it starts. Of course validators "
"with different round exponents will differ in perspective on the length of "
"this round."
msgstr ""
"Вокруг определяется по тику, с которого он начинается. Конечно, валидаторы с"
" разными экспонентами раунда будут отличаться с точки зрения "
"продолжительности этого раунда."

#: ../../theory/highway.rst:154
msgid ""
"**Example:** Alice has round exponent 5. Bob has round exponent 7. So, in "
"Alice’s world, rounds have length 32 ticks, while in Bob’s world rounds have"
" length 128 ticks. Timepoint 2019-09-13T13:13:13.088Z corresponds with tick "
"1568380393088 and is the beginning of a round for both Alice and Bob. But, "
"in Alice’s world, this round will only last for 32 milliseconds, while for "
"Bob this round will last for 128 milliseconds."
msgstr ""
"**Пример:** У Алисы экспонента раунда 5. У Боба же 7. Итак, в мире Алисы "
"раунды имеют длину 32 тика, в то время как в мире Боба раунды имеют длину "
"128 тиков. Время 2019-09-13T13:13:13.088 Z соответствует отметке - тику- "
"1568380393088 и является началом раунда как для Алисы, так и для Боба. Но в "
"мире Алисы этот раунд продлится всего 32 миллисекунды, в то время как для "
"Боба этот раунд продлится 128 миллисекунд."

#: ../../theory/highway.rst:162
msgid "Validator operation"
msgstr "Работа оператора"

#: ../../theory/highway.rst:164
msgid ""
"Contrary to NCB, the way ballots are used in Highway is more sophisticated."
msgstr ""
"В отличие от NCB, способ, которым бюллетени применяются в Highway, более "
"изощренный."

#: ../../theory/highway.rst:166
msgid ""
"In NCB a validator only produces ballots to continue participation in "
"**b-game** after doing unbonding. In Highway, only the round leader is "
"allowed to produce blocks. So if I am not the leader of current round, I am "
"going to produce only ballots."
msgstr ""
"В NCB валидатор производит бюллетени только для продолжения участия в "
"**b-игре** после анбондинга. В Highway, только лидер раунда может "
"производить блоки. Так что если я не являюсь лидером текущего раунда, я могу"
" производить только бюллетени."

#: ../../theory/highway.rst:171
msgid ""
"In details, local state and operation of a validator is similar to NCB. The "
"only difference is that we impose very precise rules on when and how to "
"create new messages."
msgstr ""
"В деталях локальное состояние и работа валидатора аналогичны NCB. "
"Единственная разница заключается в том, что мы устанавливаем очень четкие "
"правила относительно того, когда и как создавать новые сообщения."

#: ../../theory/highway.rst:176
msgid "Rule 1: ignore rounds you cannot see"
msgstr "Правило 1: игнорируйте раунды, которые вам не видны"

#: ../../theory/highway.rst:178
msgid ""
"I operate as if the world is simple and everybody uses the same round "
"exponent as I am using. Which means that I completely ignore the existence "
"of rounds starting at ticks not divisible by :math:`2^n`, where :math:`n` is"
" my round exponent."
msgstr ""
"Я действую так, как будто мир прост, и все используют ту же экспоненту "
"раунда, что и я. Это означает, что я полностью игнорирую существование "
"раундов, начинающихся с тиков, не делящихся на :math:`2^n`, где :math:`n`  -"
" моя экспонента раунда."

#: ../../theory/highway.rst:184
msgid "Rule 2: follow the leader sequence"
msgstr "Правило 2: следуйте последовательности лидеров"

#: ../../theory/highway.rst:187
msgid ""
"For every round I use the leader's pseudorandom sequence to figure out the "
"id"
msgstr ""
"Для каждого раунда я использую псевдослучайную последовательность лидеров "
"для определения id раунда"

#: ../../theory/highway.rst:187
msgid "of a validator which is the leader of this round."
msgstr "валидатора, который является лидером этого раунда."

#: ../../theory/highway.rst:190
msgid "Rule 3: lambda message"
msgstr "Правило 3: лямбда-сообщение"

#: ../../theory/highway.rst:192
msgid ""
"If I am the leader of current round, I produce new block :math:`b`, using "
"all"
msgstr ""
"Если я лидер текущего раунда, я произвожу новый блок :math:`b`, используя "
"все"

#: ../../theory/highway.rst:193
msgid ""
"tips of my local j-dag as justifications of :math:`b`. Then I broadcast"
msgstr ""
"заметки моего локального j-dag как обоснования :math:`b`. Тогда я транслирую"

#: ../../theory/highway.rst:194
msgid ":math:`b` to all validators."
msgstr ":math:`b` всем валидаторам."

#: ../../theory/highway.rst:198
msgid ""
"We call this message **the lambda message**. There is only one lambda "
"message"
msgstr ""
"Мы называем это сообщение **лямбда-сообщение**. Есть только одно лямбда-"
"сообщение"

#: ../../theory/highway.rst:197
msgid ""
"in every round. Every block :math:`b` is a lambda message of some round, "
"namely round :math:`b.round\\_id`."
msgstr ""
"в каждом раунде. Каждый блок :math:`b`  является лямбда-сообщением некого "
"раунда, а именно раунда :math:`b.round\\_id`."

#: ../../theory/highway.rst:201
msgid "Rule 4: lambda response message"
msgstr "Правило 4: ответ на лямбда-сообщение"

#: ../../theory/highway.rst:203
msgid ""
"If I am not the leader of the current round, I set up a handler for "
"receiving the lambda message from this round’s leader. This handler waits "
"for the lambda message but only up to the end of the current round. If the "
"lambda message arrives before the end of the current round, I create a "
"ballot taking as its justifications only the lambda message and my last "
"message (if I have one)."
msgstr ""
"Если я не являюсь лидером текущего раунда, я настраиваю обработчик для "
"получения лямбда-сообщения от лидера этого раунда. Этот обработчик ожидает "
"лямбда-сообщения, но только до конца текущего раунда. Если лямбда-сообщение "
"приходит до конца текущего раунда, я создаю бюллетень, принимая в качестве "
"обоснования только лямбда-сообщение и мое последнее сообщение (если оно у "
"меня есть)."

#: ../../theory/highway.rst:210
msgid "Rule 5: omega message"
msgstr "Правило 5: омега-сообщение"

#: ../../theory/highway.rst:212
msgid ""
"Let :math:`j` be the id of current round. At tick :math:`j + omega\\_delay "
"\\cdot 2^n` I create a ballot :math:`b` using all tips of my local j-dag as "
"justifications of :math:`b`."
msgstr ""
"Пусть :math:`j` будет id текущего раунда. На тике :math:`j + omega\\_delay "
"\\cdot 2^n` я создаю бюллетень :math:`b` , используя все заметки моего "
"локального j-dag как обоснования :math:`b`."

#: ../../theory/highway.rst:216
msgid ""
":math:`omega\\_delay \\in(0,1)` is a blockchain parameter - to be picked by "
"simulation and then hardcoded."
msgstr ""
":math:`omega\\_delay \\in(0,1)` - это параметр блокчейн - чтобы быть "
"выбранным симуляцией и затем жестко закодировано."

#: ../../theory/highway.rst:220
msgid "Adjusting round exponent"
msgstr "Настройка экспоненты раунда"

#: ../../theory/highway.rst:222
msgid ""
"We need to make it clear what the semantics is of adjusting the round "
"exponent. First, we want to say that the mechanics of messages creation "
"requires that a validator knows what exponent he was using at any tick. This"
" can be formalized by saying that for any validator :math:`v` there is a "
"function :math:`n_v: Int \\to Int`, assigning an exponent to be used by "
":math:`v` in any given tick."
msgstr ""
"Нам нужно прояснить, какова семантика корректировки экспоненты раунда. Во-"
"первых, мы хотим сказать, что механика создания сообщений требует, чтобы "
"валидатор знал, какой показатель он использовал в любой момент. Это можно "
"формализовать, сказав, что для любого валидатора :math:`v`  существует "
"функция :math:`n_v: Int \\to Int`, присваивающая показатель степени, который"
" будет использоваться :math:`v` в любом заданном тике."

#: ../../theory/highway.rst:229
msgid ""
"When a validator wants to adjust its round exponent, this must be done at a "
"tick that happens to be the boundary of both the old-length round and the "
"new-length round. Mathematically this transforms into saying that :math:`n_v"
" (i) = n_v(i-1)` unless :math:`i` is a multiple of both :math:`2^{n_v(i)}` "
"and :math:`2^{n_v(i-1)}`."
msgstr ""
"Когда валидатор хочет скорректировать свою экспоненту, это должно быть "
"сделано на отметке - тике, которая оказывается границей как раунда старой "
"длины, так и раунда новой длины. Математически это превращается в "
"утверждение, что :math:`n_v (i) = n_v(i-1)`, если только :math:`i` не кратно"
" обоим :math:`2^{n_v(i)}` и :math:`2^{n_v(i-1)}`."

#: ../../theory/highway.rst:238
msgid ""
"Auto-adjusting of round lengths is based on an internal finalizer which "
"every"
msgstr ""
"Автоматическая регулировка длины круга - раунда - основана на внутреннем "
"финализаторе, который каждый"

#: ../../theory/highway.rst:236
msgid ""
"validator must maintain. This finalizer would run with the fault tolerance "
"threshold :math:`ftt` set as blockchain-wide constant (:math:`ftt=1\\%` "
"sounds like a good candidate value here) and "
":math:`acknowledgement\\_level=1`."
msgstr ""
"валидатор должен поддерживать. Этот финализатор запускает порог "
"отказоусточивости :math:`ftt` , настроенный как константа для всей ширины "
"блокчейна (:math:`ftt=1\\%` кажется здесь хорошим кандидатом на значение) и "
":math:`acknowledgement\\_level=1`. "

#: ../../theory/highway.rst:240
msgid ""
"Now, we finally can define the strategy of auto-adjusting round exponents."
msgstr ""
"Тепер мы наконец можем определить стратегию авторегулировки экспоненты "
"рауна."

#: ../../theory/highway.rst:242
msgid ""
"We assume there are two blockchain-wide integer constants, both expressing "
"the number of rounds:"
msgstr ""
"Мы предполагаем, что существуют две целочисленные константы в масштабах "
"блокчейна, обе из которых выражают количество раундов:"

#: ../../theory/highway.rst:245
msgid "**round-acceleration-period** - every that-many-rounds a validator"
msgstr ""
"**раунд-период ускорения** - каждый столько-то-много-раундов валидатор"

#: ../../theory/highway.rst:246
msgid ""
"decreases its round exponent by :math:`1` (unconditionally) -  **round-"
"slowdown-period** - if a validator observes that many consecutive rounds "
"with the lambda message from the round leader not getting finalized, it "
"increases its round exponent by 1"
msgstr ""
"уменьшает показатель раунда на  :math:`1` (безоговорочно) - **период "
"замедления раунда** - если валидатор замечает, что многие последовательные "
"раунды с лямбда-сообщением от лидера раунда не завершаются, он увеличивает "
"показатель экспоненты раунда на 1"

#: ../../theory/highway.rst:252
msgid "Eras"
msgstr "Эры"

#: ../../theory/highway.rst:255
msgid "The need for eras"
msgstr "Необходимость эр"

#: ../../theory/highway.rst:257
msgid ""
"The idea of of eras is to keep the validator weights map constant for a "
"longer period of time (e.g., a week). Otherwise, it is rather difficult to "
"establish a pseudorandom leaders sequence all validators agree on. Eras also"
" plays a crucial role in making the leader selection resistant to attack."
msgstr ""
"Идея эр состоит в том, чтобы поддерживать карту весов валидатора постоянной "
"в течение более длительного периода времени (например, недели). В противном "
"случае довольно сложно установить псевдослучайную последовательность "
"лидеров, с которой согласны все валидаторы. Эры также играют решающую роль в"
" том, чтобы сделать выбор лидера устойчивым к атаке."

#: ../../theory/highway.rst:263
msgid "Boundary of an era"
msgstr "Граница эры"

#: ../../theory/highway.rst:265
msgid ""
"**Era length** is just a parameter of the blockchain - expressed as a number"
" of ticks. We expect a reasonable era length might be 604800000, which is "
"one week."
msgstr ""
"**Длина эры** - это всего лишь параметр блокчейна, выраженный в количестве "
"тиков. Мы ожидаем, что разумная продолжительность эры может составлять "
"604800000, что составляет одну неделю."

#: ../../theory/highway.rst:268
msgid ""
"A message :math:`m` belongs to an era deduced by knowing the era length and "
"looking at :math:`m.round\\_id`."
msgstr ""
"Сообщение  :math:`m`  принадлежит к эре, выделенной с помощью знания о длине"
" эры и смотря на :math:`m.round\\_id`."

#: ../../theory/highway.rst:272
msgid "Critical blocks"
msgstr "Критичные блоки"

#: ../../theory/highway.rst:274
msgid ""
"Round ids are really Unix timestamps, so main-tree can be now imagined with "
"time-axis overlayed."
msgstr ""
"Идентификаторы раундов на самом деле являются метками времени Unix, поэтому "
"теперь можно представить главное дерево с наложением оси времени."

#: ../../theory/highway.rst:277
msgid ""
"In every era, there are two ticks (with a distance fixed relative to the "
"beginning of an era):"
msgstr ""
"В каждой эре есть два тика (с фиксированным расстоянием относительно начала "
"эры):"

#: ../../theory/highway.rst:280
msgid "**booking-point**"
msgstr "**точка букинга**"

#: ../../theory/highway.rst:281
msgid "**key-point**"
msgstr "**ключевая точка**"

#: ../../theory/highway.rst:283
msgid ""
"These points are blockchain parameters and **key-point** must be strictly "
"bigger than **booking-point**."
msgstr ""
"Эти точки являются параметрами блокчейна и **ключевая точка** должна быть "
"строго больше, чем **точка букинга**."

#: ../../theory/highway.rst:286
msgid ""
"Let :math:`era\\_start: Int \\to Int` be a function that assigns to every "
"tick the beginning of an era this tick belongs to. This function can easily "
"be calculated as:"
msgstr ""
"Пусть :math:`era\\_start: Int \\to Int`  будет функцией, которая назначает "
"каждый тик к началу эры, которой он принадлежит. Эта функция может быть "
"легко вычислена как:"

#: ../../theory/highway.rst:290
msgid "era\\_start(t) = (t / era\\_length) * era\\_length"
msgstr "era\\_start(t) = (t / era\\_length) * era\\_length"

#: ../../theory/highway.rst:295
msgid "… where the division is integer division."
msgstr "... где деление-это целочисленное деление."

#: ../../theory/highway.rst:297
msgid ""
"**Booking block** is any block :math:`b` such that both following conditions"
" hold:"
msgstr ""
"**Блок букинга** это любой блок :math:`b`  при том, что оба условия "
"содержат:"

#: ../../theory/highway.rst:299
msgid ":math:`b.round\\_id \\geqslant era\\_start(b.round\\_id) + booking\\_point`"
msgstr ":math:`b.round\\_id \\geqslant era\\_start(b.round\\_id) + booking\\_point`"

#: ../../theory/highway.rst:300
msgid ":math:`b.main\\_parent.round\\_id < era\\_start(b.round\\_id) + booking\\_point`"
msgstr ""
":math:`b.main\\_parent.round\\_id < era\\_start(b.round\\_id) + "
"booking\\_point`"

#: ../../theory/highway.rst:302
msgid ""
"It can be explained as the idea that on any path of the main-tree, booking "
"block is the first block to cross the time defined by **booking-point**, "
"where we consider “time of a block” to be the tick of the beginning of its "
"era."
msgstr ""
"Это можно объяснить как идею о том, что на любом пути главного дерева блок "
"букинга является первым блоком, пересекающим время, определенное **точкой "
"букинга**, где мы считаем “время блока” отметкой - тиком - начала его эры."

#: ../../theory/highway.rst:306
msgid "By analogy, we are defining a **key block** concept."
msgstr "По аналогии, мы определяем концепт **ключевого блока**."

#: ../../theory/highway.rst:309
msgid "Leaders sequence"
msgstr "Последовательность лидеров"

#: ../../theory/highway.rst:311
msgid ""
"To have the sequence of leaders that all validators calculate in the same "
"way, we only need:"
msgstr ""
"Чтобы иметь последовательность лидеров, которую все валидаторы вычисляют "
"одинаково, нам нужно только:"

#: ../../theory/highway.rst:314
msgid ""
"1. Canonical sorting of validators so that a weights map can be converted to"
" an array of validators in the canonical way. 2. Agreement on pseudorandom "
"number generator to be used by all validators. 3. Pseudorandom generator "
"seed."
msgstr ""
"1. Каноническая сортировка валидаторов, чтобы карта весов могла быть "
"преобразована в массив валидаторов каноническим способом. 2. Соглашение о "
"генераторе псевдослучайных чисел, который будет использоваться всеми "
"валидаторами. 3. Отбор псевдослучайного генератора."

#: ../../theory/highway.rst:319
msgid ""
"For (1) sorting by validator ids can be used. (2) can be hardcoded. So it is"
" all about the way we pick the seed."
msgstr ""
"Для (1) может использоваться сортировка по идентификаторам валидатора. (2) "
"может быть жестко запрограммирован. Так что все дело в том, как мы отбираем "
"выборку."

#: ../../theory/highway.rst:323
msgid "The mechanics of an era"
msgstr "Механика эры"

#: ../../theory/highway.rst:326
msgid "The vision"
msgstr "Видение"

#: ../../theory/highway.rst:328
msgid "Eras constitute the platform on which two mechanisms work:"
msgstr "Эры представляют собой платформы, на которых работают два механизма:"

#: ../../theory/highway.rst:330
msgid "validators rotation (= bonding/unbonding)"
msgstr "ротация валидаторов (= бондинг/анбондинг)"

#: ../../theory/highway.rst:331
msgid "leaders sequence"
msgstr "последовательность лидеров"

#: ../../theory/highway.rst:333
msgid "Within a single era:"
msgstr "Внутри отдельной эры:"

#: ../../theory/highway.rst:335
msgid "the weights map is fixed"
msgstr "карта весов фиксирована"

#: ../../theory/highway.rst:336
msgid ""
"the leaders selection functions (assigning a leader to every tick) is fixed"
msgstr ""
"функции выборки лидеров (назначающие лидеров для каждого тика) фиксирована"

#: ../../theory/highway.rst:338
msgid ""
"An era starts at fixed point of real time (fixed tick). We generally expect "
"that:"
msgstr ""
"Эра начинается с фиксированной точки реального времени (фиксированный тик). "
"Мы в основном ожидаем, что:"

#: ../../theory/highway.rst:340
msgid ""
"1. The weights map to be used in this era is defined by a booking block from"
" :math:`era\\_delay` rounds ago. 2. The random seed to be used in this era "
"is defined by a key block from :math:`era\\_delay` rounds ago."
msgstr ""
"1. Карта весов, которая будет использоваться в эту эру, определяется блоком "
"букинга из :math:`era\\_delay` раундов назад. 2. Случайное начальное "
"значение, которое будет использоваться в этой эре, определяется ключевым "
"блоком из :math:`era\\_delay`  раундов назад."

#: ../../theory/highway.rst:345
msgid ""
"Both :math:`era\\_delay` is a blockchain parameter. We expect that "
"reasonable value for :math:`era\\_delay` is 2."
msgstr ""
"Оба :math:`era\\_delay` являются параметрами блокчейн. Мы ожидаем, что "
"разумное значение для :math:`era\\_delay` равно 12."

#: ../../theory/highway.rst:349
msgid "Setting the weights map"
msgstr "Настройка карты весов"

#: ../../theory/highway.rst:351
msgid ""
"Just take weights map as defined in the post-state of the corresponding "
"booking block."
msgstr ""
"Просто возьмите карту весов, как определено в пост-состоянии "
"соответствующего блока букинга."

#: ../../theory/highway.rst:354
msgid "Setting the random seed for leaders sequence generator"
msgstr ""
"Настройка рандомного отбора для генератора последовательности лидеров."

#: ../../theory/highway.rst:356
msgid ""
"Take the hash of corresponding key-block, then add all magic bits from main-"
"tree path-of-blocks between the booking block and the key block (both from "
"the same era)."
msgstr ""
"Возьмите хеш соответствующего ключевого блока, затем добавьте все магические"
" биты из пути главного дерева блоков между блоком бронирования и ключевым "
"блоком (оба из той же эры)."

#: ../../theory/highway.rst:361
msgid "Disparation of eras"
msgstr "Несоответствие эр"

#: ../../theory/highway.rst:363
msgid ""
"In an era we typically will observe many booking blocks and key blocks, just"
" because the main-tree is typically not a chain. The expectation here is "
"that the combination of :math:`era\\_delay` and :math:`key\\_point` together"
" make enough time between the key block and the beginning of the era it "
"defines, that the LFB chain of a reasonably strong finalizer will do the "
"selection of only one “official” key block."
msgstr ""
"В эру мы обычно наблюдаем множество блоков бронирования и ключевых блоков, "
"просто потому, что главное дерево обычно не является цепочкой. Здесь "
"ожидается, что комбинация :math:`era\\_delay` и :math:`key\\_point` вместе "
"составляет достаточно времени между ключевым блоком и началом определяемой "
"им эры, чтобы цепочка LFB достаточно сильного финализатора выполняла выбор "
"только одного “официального” ключевого блока."

#: ../../theory/highway.rst:370
msgid "Let us do a simple calculations:"
msgstr "Давайте произведем простые вычисления:"

#: ../../theory/highway.rst:372
msgid ""
"Assuming the era length is set to one week - starting Monday and ending "
"Sunday - and the key point is set to Thursday noon. Also, assume that "
"“era\\_delay” is 2. This means that key blocks created just after Thursday "
"noon will control the era that will start 10.5 days later. This is plenty of"
" time and by that time it is “almost sure” that the progressing LFB chain "
"will"
msgstr ""
"Предполагая, что продолжительность эры установлена на одну неделю - начиная "
"с понедельника и заканчивая воскресеньем, - а ключевой момент установлен на "
"полдень четверга. Кроме того, предположим, что “era\\_delay” равно 2. Это "
"означает, что ключевые блоки, созданные сразу после полудня четверга, будут "
"управлять эрой, которая начнется через 10,5 дней. Это достаточно много "
"времени, и к тому времени “почти наверняка”, что прогрессирующая цепочка LFB"
" будет"

#: ../../theory/highway.rst:377
msgid "pick the “right” key block to be used."
msgstr "выбирать \"правильный\" ключевой блок для использования."

#: ../../theory/highway.rst:379
msgid ""
"In the extreme case, however, the finality of the key block might not be "
"there at the moment of starting the era to be controlled by this block. This"
msgstr ""
"В крайнем случае, однако, окончательность ключевого блока может "
"отсутствовать в момент начала эры, контролируемой этим блоком. Это"

#: ../../theory/highway.rst:381
msgid ""
"is an interesting situation that actually can be handled, although this is "
"to happen in a “shocking” way. The way to go is to run in parallel all "
"possible eras - accordingly to all key blocks that are “on the table”. Of "
"course, these parallel eras must be run as if they are completely "
"independent blockchains (= separate P2p networks). Eventually, the "
"progressing LFB chain will materialize only one reality, and so all the "
"other virtual eras must disappear, so validators will just forget they ever "
"existed. This is exactly like in quantum mechanics, where at some point only"
" one version of reality is materializing."
msgstr ""
"интересная ситуация, с которой на самом деле можно справиться, хотя это "
"должно произойти “шокирующим” образом. Путь состоит в том, чтобы запустить "
"параллельно все возможные эры - соответственно всем ключевым блокам, которые"
" находятся “на столе”. Конечно, эти параллельные эры должны выполняться так,"
" как если бы они были полностью независимыми блокчейнами (= отдельными "
"сетями P2p). В конце концов, прогрессирующая цепочка LFB материализует "
"только одну реальность, и поэтому все остальные виртуальные эры должны "
"исчезнуть, поэтому валидаторы просто забудут, что они когда-либо "
"существовали. Это в точности как в квантовой механике, где в какой-то момент"
" материализуется только одна версия…"
