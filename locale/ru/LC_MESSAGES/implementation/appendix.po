# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, CasperLabs LLC
# This file is distributed under the same license as the CasperLabs Tech
# Spec package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
# 
# Translators:
# David Tsaritov <tsaritov@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: CasperLabs Tech Spec\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-23 20:03+0000\n"
"PO-Revision-Date: 2021-06-26 21:48+0000\n"
"Last-Translator: David Tsaritov <tsaritov@gmail.com>, 2021\n"
"Language-Team: Russian (https://www.transifex.com/caspernetwork/teams/122124/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../implementation/appendix.rst:4
msgid "Appendix"
msgstr "Аппендикс"

#: ../../implementation/appendix.rst:9
msgid "A - Casper Rust Library"
msgstr "А - библиотека Casper Rust "

#: ../../implementation/appendix.rst:11
msgid ""
"Casper provides low-level bindings for host-side (“external”) functions for "
"developers creating smart contracts in other programming languages. "
"Developers can import these functions into a wasm module used as a contract "
"on the Casper Network. Thus, the contract will have access to features "
"specific to the Casper platform which are not supported by general wasm "
"instructions (e.g., accessing the global state, creating new ``URef``\\ s). "
"These are defined and automatically imported if the `Casper Rust library "
"<https://crates.io/crates/casper-contract>`__ is used to develop the "
"contract. For an up-to-date description of exported functions, please visit "
"the `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ crate documentation."
msgstr ""
"Casper предоставляет низкоуровневые привязки для функций на стороне хоста "
"(“внешних”) для разработчиков, создающих смарт-контракты на других языках "
"программирования. Разработчики могут импортировать эти функции в модуль "
"wasm, используемый в качестве контракта в сети Casper. Таким образом, "
"контракт будет иметь доступ к функциям, специфичным для платформы Casper, "
"которые не поддерживаются общими инструкциями wasm (например, доступ к "
"глобальному состоянию, создание новых ``URef``\\ s). Они определяются и "
"автоматически импортируются, если библиотека `Casper Rust library "
"<https://crates.io/crates/casper-contract>`__ используется для разработки "
"контракта. Для получения обновленного описания экспортируемых функций, "
"пожалуйста, посетите раздел `casper-contract <https://docs.rs/casper-"
"contract/latest/casper_contract/ext_ffi/index.html>`__ документация по "
"крейтам."

#: ../../implementation/appendix.rst:16
msgid "B - Serialization Format"
msgstr "B - формат сериализации"

#: ../../implementation/appendix.rst:18
msgid ""
"The Casper serialization format is used to transfer data between wasm and "
"the Casper host runtime. It is also used to persist global-state data in the"
" Merkle trie. The definition of this format is described in the :ref:`global"
" state <global-state-head>` section."
msgstr ""
"Формат сериализации Casper используется для трансфера информации между wasm "
"и хостом рабочей среды Casper. Также он используется для сохранения данных о"
" глобальном состоянии в дереве Меркла. Определение этого формата описано тут"
"  :ref:`global state<global-state-head>` ."

#: ../../implementation/appendix.rst:20
msgid ""
"A Rust reference implementation for those implementing this specification in"
" another programming language can be found here:"
msgstr ""
"Справочную реализацию Rust для тех, кто реализует эту спецификацию на другом"
" языке программирования, можно найти здесь:"

#: ../../implementation/appendix.rst:22
msgid ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"
msgstr ""
"`bytesrepr <https://docs.rs/casper-"
"types/latest/casper_types/bytesrepr/index.html>`_"

#: ../../implementation/appendix.rst:23
msgid ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"
msgstr ""
"`cl_value.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/cl_value.rs.html>`_"

#: ../../implementation/appendix.rst:24
msgid ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"
msgstr ""
"`account <https://docs.rs/casper-"
"types/latest/casper_types/account/index.html>`_"

#: ../../implementation/appendix.rst:25
msgid ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"
msgstr ""
"`contract <https://docs.rs/casper-"
"types/latest/casper_types/contracts/struct.Contract.html>`_"

#: ../../implementation/appendix.rst:26
msgid ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"
msgstr ""
"`uint.rs <https://docs.rs/casper-"
"types/latest/src/casper_types/uint.rs.html>`_"

#: ../../implementation/appendix.rst:28
msgid ""
"Additionally, examples of all data types and their serializations are found "
"in the `GitHub code base <https://github.com/casper-network/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
" These examples include a set of useful `serialization tests "
"<https://github.com/casper-network/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."
msgstr ""
"Дополнительно примеры всех типов информации и их сериализации можно найти в "
"базе кодов `GitHub code base <https://github.com/casper-network/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
"  Эти примеры включают набор полезных тестов сериализации `serialization "
"tests <https://github.com/casper-network/casper-"
"node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."

#: ../../implementation/appendix.rst:35
msgid "C - Parallel Execution"
msgstr "C - параллельное исполнение"

#: ../../implementation/appendix.rst:38
msgid "Introduction"
msgstr "Введение"

#: ../../implementation/appendix.rst:40
msgid ""
"The state of the Casper Network is represented by the :ref:`global state "
"<global-state-head>`. The evolution of this state is captured by the "
"blockchain itself, and eventually agreed upon by all nodes in the network "
"via the consensus mechanism. In this section we are concerned with only a "
"single step of that evolution. We think of such a step as performing some "
"\"computation\" that changes the global state. A :ref:`deploy <execution-"
"semantics-deploys>` is a user request for computation, and contains two "
"atomic units of computation: the payment code and the session code (the "
"details of which are discussed elsewhere). For the purpose of this section, "
"we think of each of these units as a (mathematical) function which takes the"
" current global state as input, perhaps along with some other arguments, and"
" produces a new global state as output. However, since the overall global "
"state is ambient from the perspective of the session/payment code itself, "
"the global state is not an explicit parameter in any user's source code, nor"
" is there any explicit return value."
msgstr ""
"Состояние сети Casper отражается в глобальном состоянии :ref:`global state"
"<global-state-head>`. Эволюция этого состояния сохраняется самой сетью "
"блокчейн и по итогу соглашения между всеми нодами через механизм консенсуса."
" В данном разделе мы рассматриваем лишь один шаг этой эволюции. Мы думаем о "
"таком шаге, как выполнение некого \"вычисления\", которое меняет глобальное "
"состояние. Развертывание :ref:`deploy <execution-semantics-deploys>` - это "
"запрос пользователя на вычисления и включает два атомных юнита исчислений: "
"код платежа и код сессии (детали описаны в другом разделе). В целях данного "
"раздела мы думаем о каждом из этих юнитов как о (математической) функции, "
"которая берет текущее глобальное состояние как вводное, возможно с "
"некоторыми аргументами, и производит новое глобальное состояние как "
"результат. Но все же поскольку в целом глобальное состояние независимо от "
"перспектив кода сессии/платежа, глобальное состояние  - это не четкий "
"параметр в любом коде источника пользователя, и не четкая разменная "
"ценность. "

#: ../../implementation/appendix.rst:55
msgid ""
"In this section we refine this idea of computation modeled as functions, and"
" describe how it is used to enable parallel execution."
msgstr ""
"В этом разделе мы уточняем эту идею вычислений, моделируемых как функции, и "
"описываем, как она используется для обеспечения параллельного выполнения."

#: ../../implementation/appendix.rst:61
msgid "Computation as functions on the global state"
msgstr "Вычисления как функции глобального состояния"

#: ../../implementation/appendix.rst:63
msgid ""
"As discussed in the introduction, we think of computation on the Casper "
"platform as being functions from the global state, :math:`G`, to itself. "
"Naturally, we can compose two such functions, to obtain another function. "
"This corresponds to sequential execution. For example, you can think of the "
"sequence ``payment_code -> session_code`` as being the composition of two "
"individual functions, capturing the effects of the payment and session "
"codes, respectively. If there are smart contracts which are called during "
"those execution phases, you could even break these down further into a "
"sequence of those calls: ``deployed_payment_wasm -> contract_a -> contract_b"
" -> stored_session_code -> contract_c -> ...``. For notational purposes, we "
"will call the set of functions :math:`\\left\\{ f \\ \\vert \\ f: G "
"\\rightarrow G \\right\\} = End(G)`, meaning \"endomorphisms of :math:`G`.\""
msgstr ""
"Как описано во введении, мы думаем о вычислениях на платформе Casper как о "
"функциях глобального состояния к самому себе :math:`G`. Естественно, мы "
"можем сложить две таких функции, чтобы получить другую функцию. Это "
"соответствует последовательному выполнению. Например, мы можем думать о "
"последовательности код платеже-код сессии  ``payment_code -> session_code``,"
" как о сочетании двух индивидуальных функций, благополучно хранящих "
"результаты кодов сессии и кодов платежа. Если мы имеем смарт-контракты, "
"которые вызываются во время этих фаз исполнения, то можно даже разбить это в"
" дальнейшем на последовательность вызовов: ``deployed_payment_wasm -> "
"contract_a -> contract_b -> stored_session_code -> contract_c -> ...``. Для "
"нотационных целей, мы называем набор функций :math:`\\left\\{ f \\ \\vert \\"
" f: G \\rightarrow G \\right\\} = End(G)`, что означает эндоморфизмы "
"\"endomorphisms of :math:`G`.\""

#: ../../implementation/appendix.rst:74
msgid ""
"While this simple model captures sequential execution, it does not model "
"parallel execution. Parallel execution is important because it can enable "
"the execution engine to run more than one deploy at the same time, possibly "
"improving block processing times. Note: each deploy itself is still single-"
"threaded; we will not support parallel execution within a single contract or"
" deploy. This optimization is purely for the performance of the node "
"implementation, not contract developers."
msgstr ""
"Хотя эта простая модель фиксирует последовательное выполнение, она не "
"моделирует параллельное выполнение. Параллельное выполнение важно, поскольку"
" оно может позволить механизму выполнения запускать несколько развертываний "
"одновременно, что, возможно, увеличит время обработки блоков. Примечание: "
"каждое развертывание по-прежнему является однопоточным; мы не будем "
"поддерживать параллельное выполнение в рамках одного контракта или "
"развертывания. Эта оптимизация предназначена исключительно для "
"производительности реализации ноды, а не для разработчиков контрактов."

#: ../../implementation/appendix.rst:83
msgid "Computation as functions from :math:`G` to :math:`End(G)`"
msgstr "Вычисления как функции из :math:`G` в :math:`End(G)`"

#: ../../implementation/appendix.rst:85
msgid ""
"The problem with functions on the global state itself is they mutate the "
"state, potentially causing problems if we wanted to apply two such functions"
" at the same time. Therefore, we will instead think of computations as "
"outputting a description of the changes to the global state that they would "
"make if given the chance. Or phrased another way, the execution of a deploy "
"will return a function that could be applied to the global state to obtain "
"the post-state we would have obtained from running the computation while "
"mutating the global state. The reason this helps is because we can apply "
"multiple such functions to the same global state at the same time; they are "
"pure functions that do not modify the global state. Thus we can execute "
"multiple deploys in parallel and later combine their outputs (more on this "
"later)."
msgstr ""
"Проблема с функциями в самом глобальном состоянии заключается в том, что они"
" изменяют состояние, что потенциально может вызвать проблемы, если мы "
"захотим применить две такие функции одновременно. Поэтому вместо этого мы "
"будем думать о вычислениях как о выводе описания изменений в глобальном "
"состоянии, которые они могли бы внести, если бы у них была такая "
"возможность. Или, выражаясь по-другому, выполнение развертывания вернет "
"функцию, которая может быть применена к глобальному состоянию для получения "
"пост-состояния, которое мы получили бы в результате выполнения вычисления "
"при изменении глобального состояния. Причина, по которой это помогает, "
"заключается в том, что мы можем применять несколько таких функций к одному и"
" тому же глобальному состоянию одновременно; это чистые функции, которые не "
"изменяют глобальное состояние. Таким образом, мы можем выполнять несколько "
"развертываний параллельно, а затем объединять их результаты (подробнее об "
"этом позже)."

#: ../../implementation/appendix.rst:103
msgid ""
"The way this is modeled in the Casper execution engine is via the "
"|TrackingCopy|_. Executing deploys (and the contracts they call) read/write "
"from the |TrackingCopy|_ instead of the global state directly. The "
"|TrackingCopy|_ *tracks* the operations and returns the |Transforms|_ which "
"act on each key in the global state effected by the execution. Using the "
"nomenclature from the theory, this collection of keys and transforms "
"describes a function :math:`f: G \\rightarrow G` which is an endomorphism on"
" :math:`G`, i.e. an element of :math:`End(G)`."
msgstr ""
"Способ, которым это моделируется в механизме выполнения Casper, - это "
"отслеживание копии  |TrackingCopy|_. Выполнение развертываний (и контрактов,"
" которые они вызывают) чтение/запись из отслеживаемой копии |TrackingCopy|_ "
", а не напрямую из  глобального состояния. Отслеживаемая копия  "
"|TrackingCopy|_ *отслеживает* операции и возвращает преобразования  "
"|Transforms|_, которые действуют на каждый ключ в глобальном состоянии, "
"вызванном выполнением. Используя номенклатуру из теории, эта коллекция "
"ключей и преобразований описывает функцию :math:`f: G \\rightarrow G` , "
"которая является эндоморфизмом :math:`G`, т. е. элементом :math:`End(G)`."

#: ../../implementation/appendix.rst:113
msgid ""
"An important note about the returned |Transforms|_ is there is exactly one "
"``Transform`` per key that was used during the execution. Initially, this "
"may be unintuitive because a contract can use the same key multiple times, "
"however, because each deploy executes sequentially, we can use the "
"composition property discussed in the previous section to combine multiple "
"sequential operations into a single operation. Consider the following "
"example."
msgstr ""
"Важное замечание о возвращенных преобразованиях  |Transforms|_ - то, что "
"есть определенно одно \"преобразование\" на ключ, которое используется во "
"время выполнения. Изначально это может показаться неинтуитивным, посколько "
"контракт может использовать один и тот же ключ несколько раз, но поскольку "
"каждое развертывание выполняется последовательно, мы можем использовать "
"результаты сложения, описанные в предыдущем разделе, чтобы сочетать "
"несколько последовательных операций в одну. Обратите внимание на следующий "
"пример. "

#: ../../implementation/appendix.rst:130
msgid ""
"The above function reads a local variable, performs a computation which "
"depends on the current value of that variable, then writes an updated value."
" Suppose we execute this function on a global state where the value of the "
"local key is ``7``. Then the sequence of transforms on the global state "
"would be ``Read -> Write(22)`` since ``n`` would be odd and thus ``f_n`` "
"would be computed using the ``else`` case. From the perspective of state "
"changes, we only need to keep the ``Write(22)`` transform because final "
"state is the same as if we had also included the ``Read`` transform. In "
"fact, by the same reasoning, we know that we only need to keep the last "
"``Write``, whatever it happens to be, since it will be the final value on "
"the key after the computation finishes. Notice that the resulting global "
"state function does not exactly reproduce the original contract execution "
"steps; it is a *reduced trace* where only the final effect on the global "
"state is recorded [#]_. In particular, this means applying the results of "
"these executions is very fast relative to the original execution (this will "
"be importnat for how we use these traces in the next section). Also notice "
"that the transforms which are produced depend on the initial state. This "
"might be obvious since we are modeling compuation as functions :math:`f: G "
"\\rightarrow End(G)`, so this statement is simply that the function really "
"depends on its input. However, this is again an imporant concept to keep in "
"mind when working with this model of computation. Going back to our example,"
" if the value of the local key was ``16`` then the transform produced would "
"be ``Write(8)``, entirely different from the case where the initial value "
"was ``7``."
msgstr ""
"Приведенная выше функция считывает локальную переменную, выполняет "
"вычисление, которое зависит от текущего значения этой переменной, затем "
"записывает обновленное значение. Предположим, мы выполняем эту функцию в "
"глобальном состоянии, где значение локального ключа равно \"7\". Тогда "
"последовательность преобразований в глобальном состоянии будет \"Чтение -> "
"Запись(22)\" , поскольку \"n\" будет нечетным, и, следовательно, \"f_n\" "
"будет вычисляться с использованием случая \"иначе\". С точки зрения "
"изменения состояния нам нужно только сохранить преобразование "
"\"Запись(22)\", потому что конечное состояние такое же, как если бы мы также"
" включили преобразование \"Чтение\". На самом деле, исходя из тех же "
"рассуждений, мы знаем, что нам нужно сохранить только последнюю \"Запись\", "
"какой бы она ни была, поскольку это будет конечное значение ключа после "
"завершения вычисления. Обратите внимание, что результирующая функция "
"глобального состояния не в точности воспроизводит исходные этапы выполнения "
"контракта; это *сокращенная трассировка*, в которой записывается только "
"окончательное влияние на глобальное состояние [#]_. В частности, это "
"означает, что применение результатов этих исполнений происходит очень быстро"
" по сравнению с исходным выполнением (это будет важно для того, как мы "
"используем эти трассировки в следующем разделе). Также обратите внимание, "
"что производимые преобразования зависят от начального состояния. Это может "
"быть очевидно, поскольку мы моделируем вычисления как функции :math:`f: G "
"\\rightarrow End(G)`, поэтому это утверждение просто означает, что функция "
"действительно зависит от ее входных данных. Однако это опять-таки важная "
"концепция, которую следует иметь в виду при работе с этой моделью "
"вычислений. Возвращаясь к нашему примеру, если бы значение локального ключа "
"было \"16\", то произведенное преобразование было бы \"Запись(8)\", "
"совершенно отличным от случая, когда начальное значение было \"7\"."

#: ../../implementation/appendix.rst:155
msgid ""
"There is a special case of constructing reduced traces which is worth "
"calling out explicitly. Suppose the initial value of a key in the global "
"state is ``X``, and after performing the execution, the transform for that "
"key is ``Write(X)``. Then it is valid to replace that transform with "
"``Read``. This is because the computation acts like the identity function "
"(i.e. the function which makes no changes) at this key, and therefore is "
"equal to ``Read``. Notably we cannot simply remove the transfrom from the "
"map because the key was still used in some way during the computation. We "
"must have a record of what keys were used to correctly detect when deploys "
"commute (see the following sections for more details). Replacing a ``Write``"
" with a ``Read`` still has great benefits for parallel exectuion because "
"reads do commute with one another, while writes do not. This optimization in"
" the reduced traces is `applied in our reference implementation "
"<https://github.com/casper-network/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
msgstr ""
"Существует особый случай построения сокращенных трасс, который стоит назвать"
" явно. Предположим, что начальное значение ключа в глобальном состоянии "
"равно \"X\", и после выполнения преобразование для этого ключа будет "
"\"Запись(X)\". Тогда допустимо заменить это преобразование на \"Чтение\". "
"Это связано с тем, что вычисление действует как функция идентификации (т. е."
" Функция, которая не вносит изменений) в этом ключе и, следовательно, равно "
"\"Чтению\". Примечательно, что мы не можем просто удалить перенос с карты, "
"потому что ключ все еще каким-то образом использовался во время вычисления. "
"У нас должна быть запись о том, какие ключи использовались для правильного "
"определения при развертывании (более подробную информацию см. В следующих "
"разделах). Замена \"Записи\" на \"Чтение\" по-прежнему имеет большие "
"преимущества для параллельного выполнения, потому что чтения коммутируют "
"друг с другом, а записи - нет. Эта оптимизация в сокращенных трассах  "
"\"применяется в нашей эталонной реализации <https://github.com/casper-"
"network/casper-"
"node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."

#: ../../implementation/appendix.rst:172
msgid "Constructing the post-state from parallel execution"
msgstr "Сборка пост-состояния из параллельного исполнения"

#: ../../implementation/appendix.rst:174
msgid ""
"Following from the previous section, we know that deploys execute to produce"
" a ``Map<Key, Transform>`` which gives a summary (i.e. \"reduced trace\") of"
" the effects the deploy would have had on each key in the global state (keys"
" not present in the map are not effected). In the reference implementation "
"we call this the ``exec`` phase. Since creating these maps does not mutate "
"the global state, we can run as many of these as we want in parallel. "
"However, after they have been run we need to actually produce a post-state, "
"the new global state after applying the effects of the deploys (this will "
"then be used as the pre-states for deploys in the following batch of "
"executions). In the reference implementation, we call applying the "
"collection of transforms to obtain a post-state the ``commit`` phase."
msgstr ""
"Что следует из предыдущего раздела, развертывания исполняют и производят "
"карту преобразования ключей ``Map<Key, Transform>``, которая дает результат "
"(т.е. \"сокращенную трассу\") эффектов, которые развертывание оказало на "
"каждый ключ в глобальном состоянии (на ключи, не присутствующие в карте, нет"
" воздействия). В эталонной реализации мы называем это фазой исполнения "
"\"exec\". Поскольку создание этих карт не изменяет глобальное состояние, мы "
"можем запускать их столько, сколько захотим параллельно. Однако после того, "
"как они были запущены, нам нужно фактически создать пост-состояние, новое "
"глобальное состояние после применения эффектов развертываний (затем это "
"будет использоваться в качестве предварительных состояний для развертываний "
"в следующей серии выполнений). В эталонной реализации мы называем применение"
" набора преобразований для получения пост-состояния фазой фиксации - "
"\"commit\"."

#: ../../implementation/appendix.rst:186
msgid ""
"Before we can construct the post-state, we must know that one is well-"
"defined. When working with parallel execution with a shared resource, you "
"may encounter \"race conditions\". This is a situation where the outcome of "
"a parallel computation depends on the order or timing of events, in "
"particular when this timing is not explicitly controlled. Or phrased another"
" way, parallelism with a shared resource is a lie and one of the processes "
"will use the resource first, followed by the other one. A classic blockchain"
" example of a race condition is a double spend (which under an accounts "
"model, as opposed to UTXO, is the same as an overdraft on the account); one "
"payer attempts to pay two payees at the same time without enough tokens to "
"actually pay both. One payee or the other is not getting their tokens, "
"depending on the order the transactions are processed."
msgstr ""
"Прежде чем мы сможем собрать пост-состояние, мы должны знать, что оно четко "
"определено. При работе с параллельным выполнением с общим ресурсом вы можете"
" столкнуться с \"условиями гонки\". Это ситуация, когда результат "
"параллельного вычисления зависит от порядка или времени событий, в "
"частности, когда это время явно не контролируется. Или, выражаясь иначе, "
"параллелизм с общим ресурсом - это ложь, и один из процессов сначала будет "
"использовать ресурс, а затем другой. Классическим примером состояния гонки в"
" блокчейне является двойная трата (которая в соответствии с моделью "
"аккаунтов, в отличие от UTXO, аналогична овердрафту на аккаунте); один "
"плательщик пытается заплатить двум получателям одновременно, не имея "
"достаточного количества токенов, чтобы фактически заплатить обоим. Тот или "
"иной получатель платежа не получает свои токены, в зависимости от порядка "
"обработки транзакций."

#: ../../implementation/appendix.rst:200
msgid ""
"In our simple model of computation where deploys are functions on the global"
" state, this would correspond to functions that do not *commute*, that is to"
" say, the order in which we apply the functions to the global state matters:"
" :math:`f \\circ g \\not= g \\circ f`. Therefore, in order to prevent race "
"conditions, we will only allow deploys to execute in parallel if they "
"commute. Taking our more sophisticated model of computation, we have two "
"deploys: :math:`f: G \\rightarrow End(G)` and :math:`g: G \\rightarrow "
"End(G)`, and we will only allow both be committed to the same pre-state "
":math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ f(G)`, i.e. the resulting"
" maps of transforms commute."
msgstr ""
"В нашей простой модели вычисления, где развертывания являются функциями "
"глобального состояния, это будет отвечать функции, которая не *коммутирует*,"
" что и есть порядок, в котором мы применяет функции к значениям глобального "
"состояния: :math:`f \\circ g \\not= g \\circ f`. Тем самым, чтобы "
"предотвратить условия гонки, мы разрешаем развертываниям выполняться "
"параллельно, только если они коммутируют. Если взять более изощренную модель"
" исчисления, у нас есть два развертывания :math:`f: G \\rightarrow End(G)` и"
" :math:`g: G \\rightarrow End(G)`, и мы разрешим обоим лишь войти в "
"одинаковое пред-состояние :math:`G` if :math:`f(G) \\circ g(G) = g(G) \\circ"
" f(G)`, т.е. итоговые карты преобразований коммутируют."

#: ../../implementation/appendix.rst:212
msgid ""
"We will discuss how to compute whether two maps of transforms commute in the"
" next section. For now, we assume that run some set of deploys :math:`d_1, "
"d_2, d_3, \\ldots` in parallel against a fixed pre-state :math:`G` to obtain"
" a set of transform maps :math:`T_1, T_2, T_3, \\ldots`, then select only "
"the transforms that commute :math:`T_i, T_j, T_k, \\ldots` to apply to "
":math:`G`, and thus obtain the post-state :math:`G^\\prime`. The remaining "
"deploys we can all run in parallel against :math:`G^\\prime`, again choosing"
" the commuting ones to commit, obtaining :math:`G^{\\prime\\prime}`, and so "
"on. This final post-state is the same as if we had run all the deploys "
":math:`d_1, d_2, d_3, \\ldots` in sequence against :math:`G`, but perhaps "
"faster (depending on how many could commute [#]_) because we were able to "
"run in parallel batches."
msgstr ""
"И мы обсудим, как вычислить, коммутируют ли две карты преобразований, в "
"следующем разделе. А сейчас мы подытожим запуск некого набора развертываний "
":math:`d_1, d_2, d_3, \\ldots` параллельно в пред-состоянии :math:`G`  для "
"осуществления набора карт преобразований :math:`T_1, T_2, T_3, \\ldots`, "
"затем выберем только те преобразования, которые коммутируют  :math:`T_i, "
"T_j, T_k, \\ldots` и применим их в  :math:`G`, чем самым выполним пост-"
"состояние :math:`G^\\prime`. Оставшиеся развертывания мы можем все запустить"
" параллельно в  :math:`G^\\prime`, вновь выбирая из них те, что коммутируют,"
" и выполняя :math:`G^{\\prime\\prime}`, и т.д. и т.п. И это финальное пост-"
"состояние будет такое же, как если бы мы запустили все развертывания "
":math:`d_1, d_2, d_3, \\ldots` в последовательности в :math:`G`, но скорее "
"всего быстрее (в зависимости от того, сколько могут коммутировать  [#]_), "
"так как мы  могли запустить процессы в параллельных пакетах."

#: ../../implementation/appendix.rst:226
msgid ""
"Recall that committing transforms is a very fast operation relative to "
"execution, so it causes little overhead. The main overhead would come from "
"executing the same deploy against multiple different starting states because"
" it failed to commute multiple times. This can be mitigated by favoring "
"including more expensive deploys in each committed batch."
msgstr ""
"Напомним, что фиксация преобразований - это очень быстрая операция по "
"сравнению с выполнением, поэтому она вызывает небольшие накладные расходы. "
"Основные накладные расходы будут связаны с выполнением одного и того же "
"развертывания в нескольких разных начальных состояниях, поскольку оно не "
"выполнялось несколько раз. Это можно смягчить, предпочтя включать более "
"дорогостоящие развертывания в каждую зафиксированную партию-пакет."

#: ../../implementation/appendix.rst:234
msgid "Detecting when maps of transforms commute"
msgstr "Обнаружение, когда карты преобразований коммутируют"

#: ../../implementation/appendix.rst:236
msgid ""
"Two transform maps ``m_1: Map<Key, Transform>`` and ``m_2: "
"Map<Key,Transform>`` commute if for all keys ``k`` which are present in both"
" maps, the transforms ``t_1 = m_1[k]`` and ``t_2 = m_2[k]`` commute. "
"Notably, if there are no such keys then the maps trivially commute. Two "
"transforms ``t_1:Transform`` and ``t_2: Transform`` commute if:"
msgstr ""
"Две карты преобразований `m_1: Map<Key, Transform>`` и ``m_2: "
"Map<Key,Transform>`` коммутируют для всех ключей ``k``, которые присутствуют"
" в обеих картах, преобразования ``t_1 = m_1[k]`` и ``t_2 = m_2[k]`` "
"коммутируют. Примечательно, что если нет таких ключей, то карты тривиально "
"коммутируют. Два преобразования ``t_1:Transform`` и ``t_2: Transform`` "
"коммутируют если:"

#: ../../implementation/appendix.rst:242
msgid "``t_1 == t_2 == Read``"
msgstr "``t_1 == t_2 == Read``"

#: ../../implementation/appendix.rst:243
msgid ""
"``t_1`` and ``t_2`` are both of the same ``Add*`` transform variant (note "
"they do not need to contain the same values within that variant)"
msgstr ""
"``t_1`` и ``t_2`` оба являются вариативностями преобразования ``Add*``  (но "
"они не обязаны содержать одинаковые значения внутри этой вариативности)"

#: ../../implementation/appendix.rst:247
msgid ""
"where ``Add*`` is a placeholder representing any of the typed native add "
"operations (``AddInt32``, ``AddInt64``, ``AddInt128``, ``AddInt256``, "
"``AddInt512``, ``AddKeys``).  And they do not commute otherwise. A short "
"montra for this is: reads commute, adds commute, writes conflict. Note that "
"writes *always* conflict, even if they are writing the same value. Consider "
"the following example:"
msgstr ""
"где ``Add*`` - это заполнитель, представляющий любую из типизированных "
"собственных операций добавления (``AddInt32``, ``AddInt64``, ``AddInt128``, "
"``AddInt256``, ``AddInt512``, ``AddKeys``). И они не коммутируют иначе. "
"Короткая мантра для этого такова: чтения - Read - коммутируют, добавления - "
"Add - коммутируют, записи - Write - конфликтуют. Запомните, что записи "
"*всегда* конфликтуют, даже если это записи об одинаковом значении. Обратите "
"внимание на пример:"

#: ../../implementation/appendix.rst:270
msgid ""
"If the pre-state :math:`G` has ``local(\"x\") == 7`` then ``f(G)`` results "
"in the transform ``Write(10)``, and so does ``g(G)``. However, if we compose"
" ``g(f(G))`` then we obtain ``Write(100)``, and if we compose ``f(g(G))`` "
"then the result is ``Write(0)`` and hence the functions do not commute."
msgstr ""
"В пред-состоянии :math:`G` has ``local(\"x\") == 7`` тогда ``f(G)`` "
"результирует в преобразование ``Write(10)``, и то же самое происходит с "
"``g(G)``. Если же мы сложим ``g(f(G))``  то мы получим ``Write(100)``, а "
"если сложим ``f(g(G))`` , то результат будет ``Write(0)`` , и таким образом "
"функции не коммутируют. "

#: ../../implementation/appendix.rst:277
msgid "Handling Errors"
msgstr "Работа с ошибками"

#: ../../implementation/appendix.rst:279
msgid ""
"The reason we can say \"adds commute\" in our rules is because "
"mathematically addition is commutative. However, this relies on the infinite"
" nature of the number line and real computers are finite. For example, if we"
" considered the addition of three 8-bit numbers: 250, 3, and 5, any two of "
"them can be added and they commute, but attempting to add all three results "
"in an overflow error. Thus the final result depends on the order of "
"addition:"
msgstr ""
"Причина, по которой мы можем сказать \"добавления коммутируют\" в наших "
"правилах, заключается в том, что математически сложение коммутативно. Однако"
" это зависит от бесконечной природы числовой строки, а реальные компьютеры "
"конечны. Например, если мы рассмотрим добавление трех 8-разрядных чисел: "
"250, 3 и 5, любые два из них могут быть добавлены, и они коммутируют, но "
"попытка добавить все три приводит к ошибке переполнения. Таким образом, "
"конечный результат зависит от порядка сложения:"

#: ../../implementation/appendix.rst:286
msgid "250 + 3 + 5 = 253 (last addition does not happen due to the error)"
msgstr "250 + 3 + 5 = 253 (последнее сложение не произошло из-за ошибки)"

#: ../../implementation/appendix.rst:287
msgid "250 + 5 + 3 = 255"
msgstr "250 + 5 + 3 = 255"

#: ../../implementation/appendix.rst:288
msgid "3 + 5 + 250 = 8"
msgstr "3 + 5 + 250 = 8"

#: ../../implementation/appendix.rst:290
msgid ""
"Presently we circumvent this error by actually using modular arithmetic "
"(wrapped addition as it is often called in computer science). Addition in "
"modular arithmetic is still a commutative operation, so our theory holds "
"together. In our example above 250 + 5 + 3 is always equal to 3, no matter "
"what. However in the context of financial applications wrapping back to zero"
" is an unexpected behavior. For this reason we use 512-bit numbers in our "
"mint contract to represent balances, and the total number of token units "
"(motes) available is less than ``U512::MAX``, so overflow is impossible."
msgstr ""
"В настоящее время мы обходим эту ошибку, фактически используя модульную "
"арифметику (обернутое сложение, как его часто называют в информатике). "
"Сложение в модульной арифметике по-прежнему является коммутативной "
"операцией, поэтому наша теория остается верной. В нашем примере выше 250 + 5"
" + 3 всегда равно 3, несмотря ни на что. Однако в контексте финансовых "
"приложений возврат к нулю является неожиданным поведением. По этой причине "
"мы используем 512-разрядные числа в нашем контракте выпуска токенов для "
"представления баланса, а общее количество доступных единиц токенов (motes) "
"меньше, чем ``U512::MAX``, поэтому переполнение невозможно."

#: ../../implementation/appendix.rst:299
msgid ""
"That said, this is not the only error which may arise due to the finite "
"nature of computers. For example, the ``AddKeys`` transform is about adding "
"elements to a map, which is a commutative operation as well (so long as none"
" of the keys already existed in the map, then it is more akin to a write "
"operation). Yet, this operation can also fail due to the physical machine "
"being out of memory, thus once again meaning the order of additions could "
"effect the final state of the map."
msgstr ""
"Тем не менее, это не единственная ошибка, которая может возникнуть из-за "
"конечной природы компьютеров. Например, преобразование ``AddKeys`` связано с"
" добавлением элементов на карту, что также является коммутативной операцией "
"(пока ни один из ключей еще не существовал на карте, это больше похоже на "
"операцию записи). Тем не менее, эта операция также может завершиться "
"неудачно из-за нехватки памяти у физической машины, что еще раз означает, "
"что порядок добавлений может повлиять на конечное состояние карты."

#: ../../implementation/appendix.rst:307
msgid ""
"In a more powerful theory of parallel execution we could consider operations"
" which fail. In this case we could say that transforms ``t_1`` and ``t_2`` "
"commute if they are of the same addition type and the outcome of applying "
"both to the input global state, :math:`G` is not an error. This is a more "
"complex rule because it requires doing some amount of computation during "
"commutativity checking, whereas the previous theory was simple comparison. "
"Yet, this theory might be worth pursuing because it solves the two problems "
"we have listed here (overflow and out-of-memory), along with other problems "
"that we presently cannot handle at all. For example, ``Minus`` could be "
"introduced as a transform, and underflows could be handled using this "
"refined commutativity rule. This has practical application in our system "
"because it would mean transfers from the same source could commute if enough"
" funds are available, whereas presently they will always be conservatively "
"labeled as not commuting."
msgstr ""
"В более мощной теории параллельного выполнения мы могли бы рассмотреть "
"операции, которые завершаются неудачей. В этом случае мы могли бы сказать, "
"что преобразования``t_1`` и ``t_2`` коммутируют, если они имеют один и тот "
"же тип сложения, и результат применения обоих к входному глобальному "
"состоянию :math:`G` не является ошибкой. Это более сложное правило, "
"поскольку оно требует выполнения некоторого объема вычислений во время "
"проверки коммутативности, в то время как предыдущая теория была простым "
"сравнением. Тем не менее, эту теорию, возможно, стоит продолжить, потому что"
" она решает две проблемы, которые мы перечислили здесь (переполнение и "
"нехватка памяти), наряду с другими проблемами, с которыми мы в настоящее "
"время вообще не можем справиться. Например, \"Минус\" может быть введен в "
"качестве преобразования, а переполнения могут обрабатываться с "
"использованием этого уточненного правила коммутативности. Это имеет "
"практическое применение в нашей системе, поскольку это означало бы, что "
"переводы из одного и того же источника могут осуществляться при наличии "
"достаточного количества средств, в то время как в настоящее время они всегда"
" будут консервативно помечены как не коммутирующие."

#~ msgid ""
#~ "Additionally, examples of all data types and their serializations are found "
#~ "in the `GitHub code base <https://github.com/CasperLabs/casper-"
#~ "node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
#~ " These examples include a set of useful `serialization tests "
#~ "<https://github.com/CasperLabs/casper-"
#~ "node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."
#~ msgstr ""
#~ "В дополнение, примеры всех типов информации и их сериализации можно найти в "
#~ "базе кодов  `GitHub code base <https://github.com/CasperLabs/casper-"
#~ "node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L26>`_."
#~ " Эти примеры включают набор полезных тестов сериализации `serialization "
#~ "tests <https://github.com/CasperLabs/casper-"
#~ "node/blob/553b9f11eb3b1e8043acfe3fa04005d951047c4a/types/src/bytesrepr.rs#L1189>`_."

#~ msgid ""
#~ "There is a special case of constructing reduced traces which is worth "
#~ "calling out explicitly. Suppose the initial value of a key in the global "
#~ "state is ``X``, and after performing the execution, the transform for that "
#~ "key is ``Write(X)``. Then it is valid to replace that transform with "
#~ "``Read``. This is because the computation acts like the identity function "
#~ "(i.e. the function which makes no changes) at this key, and therefore is "
#~ "equal to ``Read``. Notably we cannot simply remove the transfrom from the "
#~ "map because the key was still used in some way during the computation. We "
#~ "must have a record of what keys were used to correctly detect when deploys "
#~ "commute (see the following sections for more details). Replacing a ``Write``"
#~ " with a ``Read`` still has great benefits for parallel exectuion because "
#~ "reads do commute with one another, while writes do not. This optimization in"
#~ " the reduced traces is `applied in our reference implementation "
#~ "<https://github.com/CasperLabs/casper-"
#~ "node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
#~ msgstr ""
#~ "Существует особый случай построения сокращенных трасс, который стоит назвать"
#~ " явно. Предположим, что начальное значение ключа в глобальном состоянии "
#~ "равно \"X\", и после выполнения преобразование для этого ключа будет "
#~ "\"Запись(X)\". Тогда допустимо заменить это преобразование на \"Чтение\". "
#~ "Это связано с тем, что вычисление действует как функция идентификации (т. е."
#~ " Функция, которая не вносит изменений) в этом ключе и, следовательно, равно "
#~ "\"Чтению\". Примечательно, что мы не можем просто удалить перенос с карты, "
#~ "потому что ключ все еще каким-то образом использовался во время вычисления. "
#~ "У нас должна быть запись о том, какие ключи использовались для правильного "
#~ "определения при развертывании (более подробную информацию см. В следующих "
#~ "разделах). Замена \"Записи\" на \"Чтение\" по-прежнему имеет большие "
#~ "преимущества для параллельного выполнения, потому что чтения коммутируют "
#~ "друг с другом, а записи - нет. Эта оптимизация в сокращенных трассах  "
#~ "применяется в нашей эталонной реализации `applied in our reference "
#~ "implementation <https://github.com/CasperLabs/casper-"
#~ "node/blob/master/execution_engine/src/core/engine_state/execution_result.rs#L439>`__."
